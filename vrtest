-- // services
local Workspace = game:GetService("Workspace"); 
local Players = game:GetService("Players"); 

local RunService = game:GetService("RunService"); 
local UserInputService = game:GetService("UserInputService");
local VRService = game:GetService("VRService"); 

game:GetService("StarterGui"):SetCore("VRLaserPointerMode", 0);
game:GetService("StarterGui"):SetCore("VREnableControllerModels", false);

-- // constants
local Player = Players.LocalPlayer
local CurrentCamera = Workspace.CurrentCamera

local ServerEndpoint = Player.Backpack:FindFirstChild("ServerEndpoint", true); 

RunService.RenderStepped:Connect(function()
	CurrentCamera.CameraType = Enum.CameraType.Scriptable
	CurrentCamera.HeadScale = 3 
end); 

-- // functions 
local PerformAction = function(ActionName, ...)
	return ServerEndpoint:InvokeServer(ActionName, ...); 
end 

local CreateLimb = function(Properties)
	local Limb = ServerEndpoint:InvokeServer("CreatePart", "Normal", CFrame.new(0,0,0), Workspace); 
	
	Limb.CanCollide = false
	Limb:GetPropertyChangedSignal("CanCollide"):Connect(function()
		Limb.CanCollide = false
	end); 

	local PatchedProperties = {} 
	for PropName, PropValue in next, Properties do 
		PatchedProperties[PropName .. "\0"] = PropValue
	end

	task.spawn(function()
		PerformAction("SyncSurface", {
			{
				Part = Limb,
				Surfaces = PatchedProperties
			}
		})
	end);

	return Limb 
end 

-- // create limbs
local Character = Player.Character
local Torso = Character:FindFirstChild("LowerTorso"); 
local Humanoid = Character:FindFirstChild("Humanoid"); 

Humanoid.Sit = true 
Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false); 

local Head = CreateLimb({ Name = "Head", CanCollide = false, Size = Vector3.new(1,1,1) * (CurrentCamera.HeadScale+1) }); 
local RHand, LHand = CreateLimb({ Name = "RHand", CanCollide = true, Size = Vector3.new(2,1,1) * (CurrentCamera.HeadScale-1) }), CreateLimb({ Name = "LHand", CanCollide = true, Size = Vector3.new(2,1,1) * (CurrentCamera.HeadScale-1) }); 

RHand.Transparency = .5
Head.Transparency = 1
LHand.Transparency = .5

local RHandOffset = Vector3.new(0,90,0);
local LHandOffset = Vector3.new(0,90,0);

-- // update
local ThumbstickInput1 = Vector2.zero
local ThumbstickInput2 = Vector2.zero 

for _, Jeep in next, Workspace.Map1.Jeeps:GetChildren() do 
	if Jeep.Name == "Jeep" then
		Jeep:Destroy(); 
	end
end Workspace.Map1.Jeeps.ChildAdded:Connect(function(Child)
	task.defer(function()
		Child:Destroy(); 
	end);
end); 

UserInputService.InputBegan:Connect(function(Input, Processed)
	if Processed then return end 

	if Input.UserInputType == Enum.UserInputType.MouseButton1 then
		RearTriggerHeld = true 
	end
end); 

UserInputService.InputEnded:Connect(function(Input, Processed)
	if Input.UserInputType == Enum.UserInputType.Gamepad1 and Input.KeyCode == Enum.KeyCode.Thumbstick2 then
		ThumbstickInput2 = Vector2.zero
	end

	if Input.UserInputType == Enum.UserInputType.Gamepad1 and Input.KeyCode == Enum.KeyCode.Thumbstick1 then
		ThumbstickInput1 = Vector2.zero
	end
end); 

UserInputService.InputChanged:Connect(function(Input)
	if Input.UserInputType == Enum.UserInputType.Gamepad1 and Input.KeyCode == Enum.KeyCode.Thumbstick2 then
		ThumbstickInput2 = Input.Position
	end

	if Input.UserInputType == Enum.UserInputType.Gamepad1 and Input.KeyCode == Enum.KeyCode.Thumbstick1 then
		ThumbstickInput1 = Input.Position 
	end
end); 

UserInputService.UserCFrameChanged:Connect(function(CFrameType, Position)
	if CFrameType == Enum.UserCFrame.Head then
		task.spawn(function()
			PerformAction("SyncMove", {
				{
					Part = Head,
					Anchored = true,
					CFrame = CurrentCamera.CFrame*(CFrame.new(Position.p*(CurrentCamera.HeadScale-1))*Position)
				}
			})
		end); 
	elseif CFrameType == Enum.UserCFrame.LeftHand then
		task.spawn(function()
			PerformAction("SyncSurface", {
				{
					Part = LHand,
					Surfaces = {
						["CFrame\0"] = CurrentCamera.CFrame*(CFrame.new(Position.p*(CurrentCamera.HeadScale-1))*Position*CFrame.Angles(math.rad(LHandOffset.X),math.rad(LHandOffset.Y),math.rad(LHandOffset.Z)))
					}
				}
			})
		end); 
	elseif CFrameType == Enum.UserCFrame.RightHand then
		task.spawn(function()
			PerformAction("SyncSurface", {
				{
					Part = RHand,
					Surfaces = {
						["CFrame\0"] = CurrentCamera.CFrame*(CFrame.new(Position.p*(CurrentCamera.HeadScale-1))*Position*CFrame.Angles(math.rad(RHandOffset.X),math.rad(RHandOffset.Y),math.rad(RHandOffset.Z)))
					}
				}
			})
		end); 
	end
end);

local RotationOffset = Vector3.new(180,180,0)
RunService.RenderStepped:Connect(function()
	if ThumbstickInput1.Magnitude > 0.1 then
		local MoveDir = RHand.CFrame * CFrame.Angles(math.rad(RHandOffset.X-RotationOffset.X),math.rad(RHandOffset.Y-RotationOffset.Y),math.rad(RHandOffset.Z-RotationOffset.Z)).LookVector

		if ThumbstickInput1.Y > -0.1 then
			MoveDir = -MoveDir
		end

		CurrentCamera.CFrame = CurrentCamera.CFrame:Lerp(CurrentCamera.CoordinateFrame + MoveDir * CurrentCamera.HeadScale * 0.05, 0.2)
	end

	if ThumbstickInput2.Magnitude > 0.1 then
		local Yaw = -ThumbstickInput2.X * 2.5
		CurrentCamera.CFrame = CurrentCamera.CFrame * CFrame.Angles(0,math.rad(Yaw),0); 
	end
end); 
