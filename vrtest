-- // services
local vrService = game:GetService("VRService");
local players = game:GetService("Players");
local userInputService = game:GetService("UserInputService"); 

game:GetService("StarterGui"):SetCore("VRLaserPointerMode", 0);
game:GetService("StarterGui"):SetCore("VREnableControllerModels", false);

-- // constants
local lp = players.LocalPlayer
local currentCamera = workspace.CurrentCamera 

local serverEndpoint = lp.Backpack:FindFirstChild("ServerEndpoint", true);

-- // functions 
local performAction = function(actionName, ...)
	return serverEndpoint:InvokeServer(actionName, ...); 
end 

local createLimb = function(properties)
	local fakeLimb = serverEndpoint:InvokeServer("CreatePart", "Normal", CFrame.new(0,0,0), game.Workspace); 
	
	local patchedProperties = {}
	for key, value in next, properties do 
		patchedProperties[key .. "\0"] = value 
	end

	task.spawn(function()
		serverEndpoint:InvokeServer("SyncSurface", {{
			Part = fakeLimb,
			Surfaces = patchedProperties
		}})
	end);	

	return fakeLimb
end 

-- // setup limbs
local character = lp.Character
local Ltorso = character:FindFirstChild("LowerTorso"); 

Ltorso:Destroy(); 

local useCollision = false
local canFling = false

local Head = createLimb({ Name = "Head", CanCollide = false }); 
local LHand = createLimb({ Name = "LHand", CanCollide = useCollision, Size = Vector3.new(1,1,5) });
local RHand = createLimb({ Name = "RHand", CanCollide = useCollision, Size = Vector3.new(1,1,5) });

LHand.Transparency = 0.5
Head.Transparency = 0.5
RHand.Transparency = 0.5

-- // setup connections 
userInputService.InputBegan:Connect(function(input, gameProcessed)
	if gameProcessed then return end 

	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		useCollision = true

		if userInputService:IsKeyDown(Enum.UserInputType.MouseButton2) then
			canFling = true
		end
	elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
		if userInputService:IsKeyDown(Enum.UserInputType.MouseButton1) then
			canFling = true
		end
	end
end);

userInputService.InputEnded:Connect(function(input, gameProcessed)
	if gameProcessed then return end 

	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		useCollision = false
		canFling = false
	elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
		canFling = false
	end
end);

userInputService.UserCFrameChanged:Connect(function(part,move)
	if part == Enum.UserCFrame.Head then
		task.spawn(function()
			serverEndpoint:InvokeServer("SyncMove", {
				{
					Part = Head,
					Anchored = true,
					CFrame = currentCamera.CFrame*(CFrame.new(move.p*(currentCamera.HeadScale-1))*move)
				}
			})
		end); 
	elseif part == Enum.UserCFrame.LeftHand then
		task.spawn(function()
			serverEndpoint:InvokeServer("SyncSurface", {
				{
					Part = LHand,
					Surfaces = {
						["CFrame\0"] = currentCamera.CFrame*(CFrame.new(move.p*(currentCamera.HeadScale-1))*move) * CFrame.new(-1.3 * currentCamera.HeadScale,-1.5,-3.5) * CFrame.Angles(0,0,0), 
						["CanCollide\0"] = useCollision
					}
				}
			})
		end); 
	elseif part == Enum.UserCFrame.RightHand then
		task.spawn(function()
			serverEndpoint:InvokeServer("SyncSurface", {
				{
					Part = RHand,
					Surfaces = {
						["CFrame\0"] = currentCamera.CFrame*(CFrame.new(move.p*(currentCamera.HeadScale-1))*move) * CFrame.new(1.3 * currentCamera.HeadScale,-1.5,-3.5) * CFrame.Angles(0,0,0),
						["CanCollide\0"] = useCollision
					}
				}
			})
		end); 
	end
end);
