-- // services
local Workspace = game:GetService("Workspace"); 
local Players = game:GetService("Players"); 

local RunService = game:GetService("RunService"); 
local UserInputService = game:GetService("UserInputService");
local VRService = game:GetService("VRService"); 

game:GetService("StarterGui"):SetCore("VRLaserPointerMode", 0);
game:GetService("StarterGui"):SetCore("VREnableControllerModels", false);

-- // constants
local Player = Players.LocalPlayer
local CurrentCamera = Workspace.CurrentCamera

local ServerEndpoint = Player.Backpack:FindFirstChild("ServerEndpoint", true); 

RunService.RenderStepped:Connect(function()
	CurrentCamera.CameraType = Enum.CameraType.Scriptable
	CurrentCamera.HeadScale = 3 
end); 

-- // functions 
local PerformAction = function(ActionName, ...)
	return ServerEndpoint:InvokeServer(ActionName, ...); 
end 

local CreateLimb = function(Properties)
	local Limb = ServerEndpoint:InvokeServer("CreatePart", "Normal", CFrame.new(0,0,0), Workspace); 
	
	Limb.CanCollide = false
	Limb:GetPropertyChangedSignal("CanCollide"):Connect(function()
		Limb.CanCollide = false
	end); 

	local PatchedProperties = {} 
	for PropName, PropValue in next, Properties do 
		PatchedProperties[PropName .. "\0"] = PropValue
	end

	task.spawn(function()
		PerformAction("SyncSurface", {
			{
				Part = Limb,
				Surfaces = PatchedProperties
			}
		})
	end);

	return Limb 
end 

-- // create limbs
local Character = Player.Character
local Torso = Character:FindFirstChild("LowerTorso"); 
local Humanoid = Character:FindFirstChild("Humanoid"); 

Humanoid.Sit = true 
Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false); 

local Head = CreateLimb({ Name = "Head", CanCollide = true, Size = Vector3.new(1,1,1) * (CurrentCamera.HeadScale+1) }); 
local RHand, LHand = CreateLimb({ Name = "RHand", CanCollide = true, Size = Vector3.new(2,1,1) * (CurrentCamera.HeadScale-1) }), CreateLimb({ Name = "LHand", CanCollide = true, Size = Vector3.new(2,1,1) * (CurrentCamera.HeadScale-1) }); 

RHand.Transparency = .5
Head.Transparency = 1
LHand.Transparency = .5

local RHandOffset = Vector3.new(0,90,0);
local LHandOffset = Vector3.new(0,90,0);

task.spawn(function()
	local BoomBox = Player.Backpack:FindFirstChild("BoomBox");

	BoomBox.Parent = Player.Character
	task.wait(0.3); 
	PerformAction("SyncSurface", {
		{
			Part = BoomBox.Handle,
			Surfaces = {
				["Anchored\0"] = true,
				["CFrame\0"] = RHand.CFrame * CFrame.Angles(math.rad(RHandOffset.Y), math.rad(RHandOffset.Y),0) * CFrame.new(0,RHand.Size.Z * 1,0);
			}
		}
	});

	BoomBox.Handle:BreakJoints(); 
	local Welds = PerformAction("CreateWelds", {BoomBox.Handle}, RHand); 

	PerformAction("SyncSurface", {
		{
			Part = BoomBox.Handle,
			Surfaces = {
				["Anchored\0"] = false,
				["CFrame\0"] = RHand.CFrame * CFrame.Angles(math.rad(RHandOffset.Y), math.rad(RHandOffset.Y),0) * CFrame.new(0,RHand.Size.Z * 1,0);
			}
		}
	});
end);

-- // update
local RearTriggerHeld = false

for _, Jeep in next, Workspace.Map1.Jeeps:GetChildren() do 
	if Jeep.Name == "Jeep" then
		Jeep:Destroy(); 
	end
end Workspace.Map1.Jeeps.ChildAdded:Connect(function(Child)
	task.defer(function()
		Child:Destroy(); 
	end);
end); 

UserInputService.InputBegan:Connect(function(Input, Processed)
	if Processed then return end 

	if Input.UserInputType == Enum.UserInputType.MouseButton1 then
		RearTriggerHeld = true 
	end
end); 

UserInputService.InputEnded:Connect(function(Input, Processed)
	if Input.UserInputType == Enum.UserInputType.MouseButton1 then
		RearTriggerHeld = false
	end
end); 

UserInputService.UserCFrameChanged:Connect(function(CFrameType, Position)
	if CFrameType == Enum.UserCFrame.Head then
		task.spawn(function()
			PerformAction("SyncMove", {
				{
					Part = Head,
					Anchored = true,
					CFrame = CurrentCamera.CFrame*(CFrame.new(Position.p*(CurrentCamera.HeadScale-1))*Position)
				}
			})
		end); 
	elseif CFrameType == Enum.UserCFrame.LeftHand then
		task.spawn(function()
			PerformAction("SyncSurface", {
				{
					Part = LHand,
					Surfaces = {
						["CFrame\0"] = CurrentCamera.CFrame*(CFrame.new(Position.p*(CurrentCamera.HeadScale-1))*Position*CFrame.Angles(math.rad(LHandOffset.X),math.rad(LHandOffset.Y),math.rad(LHandOffset.Z)))
					}
				}
			})
		end); 
	elseif CFrameType == Enum.UserCFrame.RightHand then
		task.spawn(function()
			PerformAction("SyncSurface", {
				{
					Part = RHand,
					Surfaces = {
						["CFrame\0"] = CurrentCamera.CFrame*(CFrame.new(Position.p*(CurrentCamera.HeadScale-1))*Position*CFrame.Angles(math.rad(RHandOffset.X),math.rad(RHandOffset.Y),math.rad(RHandOffset.Z)))
					}
				}
			})
		end); 
	end
end);

local RotationOffset = Vector3.new(180,180,0)
RunService.RenderStepped:Connect(function()
	if RearTriggerHeld then
		CurrentCamera.CFrame = CurrentCamera.CFrame:Lerp(CurrentCamera.CoordinateFrame + (RHand.CFrame * CFrame.Angles(math.rad(RHandOffset.X-RotationOffset.X),math.rad(RHandOffset.Y-RotationOffset.Y),math.rad(RHandOffset.Z-RotationOffset.Z))).LookVector * CurrentCamera.HeadScale/2, 0.5)
	end
end); 
